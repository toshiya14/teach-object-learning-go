# 指针

## 栈区和堆区的定义

当我们声明一个变量，比如 `var a int = 1`，声明一个整型变量。
实际上电脑会在 **栈区** 记录：**变量a** 和 **一个内存地址**，而在 **堆区** 对应的位置，放入一个整型数据 `1`。

* 栈区：可以看作是，记录变量名和对应地址的一个表。
* 堆区：就是数据存储的地方。

光有堆区的数据，你无法知道具体某个位置的变量是什么类型的，以及它叫什么。

光有栈区的数据，你就无法知道变量具体的值是什么。

所以这两个是都是必不可少的。

## 指针的定义

指针是只包含变量类型和内存地址的一种特殊变量。

例如：

```go
var a int = 1
var ap *int = &a
```

第二行定义的 `ap`，就是一个整数指针，它指向了 `a` 变量的堆区地址。

指针的类型可以是 `int`、`float` 这种普通数值类型，也可以是结构类型，包括自定义的结构。

需要什么类型的指针，就是 `*类型名` 的格式。

> C 语言中允许 `ap++` 对指针进行向后移动一位的操作。
> 但是 Go 语言中不允许这种不安全的指针操作。

## 取地址和取值

`&` 符号在这里，是取地址符号，意义是将 `a` 变量的地址获取出来，并返回给前面的指针。
取地址符号只能对实际变量进行使用，不可用于常量和指针。

同时我们也可以用 `*ap` 来获取 `ap` 指向的堆区数据的实际值。这里 `*ap` 实际上跟 `a` 的值是一样的。
取值符号只能对指针使用。

通常这两个符号的作用是相对的。

## 指针的取值和原变量的关系

```go
var a int = 1
var ap *int = &a
a++

fmt.Println(*ap)
```

以上程序输出的结果会是什么？

答：`2`。

由于 `ap` 指针指向的是 `a` 变量的实际值，所以一旦 `a` 发生了变化， `ap` 所能取到的值也会对应发生变化。

## 什么情况下用指针

### 确定地需要指向同一个变量时

```go
package main

import "fmt"

func add1(a int) {
	a = a + 1
	fmt.Printf("a(address): %v, a: %v\n", &a, a)
}

func add2(ap *int) {
	*ap = *ap + 1
	fmt.Printf("ap(address): %v, ap: %v\n", ap, *ap)
}

func main() {
	var num int = 1
	fmt.Printf("num(address): %v, num: %v\n", &num, num)
	add1(num)
	fmt.Printf("num: %v\n", num)
	add2(&num)
	fmt.Printf("num: %v\n", num)
}
```

`*ap = *ap + 1` 这一行实际上是将 `ap` 指针的值取出来之后，加一，再写回去。

> 但是
> 如果，你写成
> ```go
> a := *ap
> a = a + 1
> ```
> 结果会不同，因为第一行中， `*ap` 取值后，会复制一份，再赋值给前面的 `a`，这个时候，`a` 相当于与 `*ap` 指向的值没有了任何关联。


`add1` 和 `add2` 的结果一样吗？

答：第一个 `add1` 会将 `num` 复制一份，传递给形参 `a`。然后计算的结果放在了赋值后的 `a` 中，并不会影响到外面的 `num`。
第二个 `add2` 也会将参数赋值一份，但是由于传入的是 `num` 的地址，所以里面的 `ap` 跟 `num` 指向同一个地址，作出的改动就会影响到外面。

### 使用复杂结构时减少内存使用

由于传参、返回和赋值都会对数据进行复制，一旦我们有了一些很大的结构或者数组，每次复制的开销就会很大，这个时候，我们就可以考虑使用指针来传参和返回。

## 自动解引用

假设
```go
type Person struct {
    Name string
    Age int
}
Zhangsan := &Person{Name: "Zhangsan", Age: 18}
```

如果你习惯使用 C/C++，你可能会对下面的调用形式比较熟悉：
`Zhangsan->Name` 或者 `(*Zhangsan).Name`。
而 Go 语言中，不需要这样写，直接写作：
`Zhangsan.Name` 即可。

## nil 空指针

当一个指针声明之后没有初始化时，零值是 `nil`。我们也可以手动赋值 `nil` 给指针，表示该指针现在没有指向任何内存地址。

```go
var p *int
```

**不可对一个空指针进行解引用（取值）操作。**

> 以下类型的零值也是 `nil`：
> * 函数类型
> * Slice 切片
> * Map 映射