# 数组和切片

* 数组： 若干个**相同类型**的变量组合而成的**连续**的内存区间，长度是固定的。
* 切片： 数组中的一部分可变长度的空间，每个切片都控制一个底层数组，所以切片也可以看作是方便操作数组的一个工具。

## 数组

### 声明方法

```go
var 变量名（数组名） [长度]元素类型

var temp [15]float32
```

比如说这里定义了一个`temp`数组，每个元素是一个`float32`的类型，总共有15个元素。用来存储某个人最近15天的体温。

如果我们要获取第一个元素，使用`temp[0]`可以获取到。

如果我们要设置元素的值，直接赋值即可，例如：`temp[0] = 35.8`。

### 长度

如果我们希望知道一个数组名所表示的数组，他的长度是多少，可以用`len()`函数来获取。

```go
var temp_count = len(temp)
```

### 默认值

在声明数组之后，所有的元素都会有一个默认值，通常是元素类型的默认值（零值）。

比如，`int`类型的零值是`0`。`string`类型的零值是`""`。

### 越界

例如，上面我们定义的`temp`数组，长度是`15`，当我们使用`temp[15]`进行访问的时候，他会获取第16个元素的值。
但是`temp`数组长度最多是`15`，就会出现越界的问题，程序会出错。

一般来说，如果出现越界，编译器会报错，不会通过编译。
但是如果编译器没有发现越界问题，程序运行的时候，会出现`panic`，导致程序直接异常退出。

> Panic 以及异常处理相关内容，请参考后面的 异常处理 相关章节。

### 初始化时赋值

```go
temp_str := [5]string {"a", "b", "c", "d", "e"}
temp_str := [...]string {"a", "b", "c", "d", "e"}
```

下面的写法只是让编译器自动推断这个数组的长度为 `5`，并不会因为使用`...`而导致数组变成可变长度。

### 遍历

#### for 循环方式

```go
for i:= 0; i < len(temp_str); i++ {
    element = temp_str[i]
    fmt.Println(i, element)
}
```

输出结果：
```
0 a
1 b
2 c
3 d
4 e
```

#### range 模式

```go
for i, element := range temp_str {
    fmt.Println(i, element)
}
```

结果同上。

### 参数传递

当数组作为参数传递的时候，或者赋值给新变量的时候，都会自我克隆一个副本再传递出去。

### 数组长度也是类型的一部分

```go
var arr1 [8]int
arr2 := [4]int { 1, 2, 3, 4 }
arr1 = arr2 // 报错
```

## 切片

```go
var 变量名 := 底层数组[起始下标:结束下标（不包含）]
```

切片是操作数组的一个上层类型，所以每个切片都有一个底层数组。

```go
[]string arr
```

上面声明了一个元素类型为`string`的切片。

```go
var arr := [8]int{1, 2, 3, 4, 5, 6, 7, 8}
var slc := arr[0:8]
var first4 := arr[0:4]
```

`slc`和`first4`就是建立在`arr`上的一个切片。
这里两个都是切片类型，而且都可以操作 `arr` 数组，但是内存中，仅存在一个 `arr` 数组。

### 缺省切片初始化

```go
var slc := arr[:4]
```

等效于 `arr[0:4]`，缺省起始下标，会设置为默认`0`。

```go
var slc := arr[4:]
```

等效于 `arr[4:len(arr)]`，缺省结束下标，会设置为`len(arr)`，这里就是从`4`开始，一直到数组末尾。


```go
var slc := arr[:]
```

包含所有元素的切片。

### 底层数组

```go
var arr := int[4] { 1, 2, 3, 4 }
var slc := arr[:2]

arr = int[4] { 5, 6, 7, 8}
fmt.Println(slc)
```

输出结果是： `[1, 2]`

第一步中，将 `arr` 初始化为 `[1, 2, 3, 4]`。
第二步中，将 `arr` 作为 `slc` 的底层数组，并且区间设置为 `[:2]`。
第三步中，新建了一个数组 `[5, 6, 7, 8]`，并将 `arr` 指向了新建的数组。
此时，`slc`的底层数组，并不会因为 `arr` 而变化，还是原本的 `[1, 2, 3, 4]`，所以 `slc` 的输出结果是 `[1, 2]`。

### 字符串切片

切片也可以用于字符串，因为字符串本身可以看作是一个由字符组成的数组。

```go
var str1 := "bilibili"
var slc := str1[:4]
fmt.Println(slc)
```

输出结果为：`bili`。

在字符串上建立切片时，数组下标表示字节下标，而不是字符下标。也就是说，如果包含中文等多字节字符的时候，需要小心可能会出现在一个字中间截断的可能。

### 添加元素

```go
var arr := []int { 1, 2, 3 }
append(arr, 4)
fmt.Println(arr)
```

输出 `[1 2 3 4]`。

也可以同时添加多个：

```go
append(arr, 5, 6, 7)
```

`arr` 此时为 `[1 2 3 4 5 6 7]`。

> 若添加元素之前，切片没有初始化，此时值为 `nil`。
> 执行 `append` 时，会当作空白的切片处理，不会报错。

### 长度和容量

* 长度：切片拥有多少个元素。通过 `len(slc)` 获取。
* 容量：切片元素在到达容量之前，不会新建底层数组。通过 `cap(slc)` 获取。

当调用 `append` 对切片进行元素追加的时候，若容量超过上限，就会创建新的底层数组扩展长度，并将原有的元素复制一份。

### 强制新建底层数组

```go
slc := arr[0:4:4]
```

将`[0:4]`切片的元素拷贝到新建底层数组，并设置容量为`4`。

### make

```go
slc := make([]int, 0, 10)
```

创建了一个 `[]int` 切片，长度是 `0`， 容量为 `10`。

### 元素展开

假设有一个函数

```go
func sum(a int, b ...int) {
    // 计算 a 以及 所有 b 的和
}
```

且有两个变量

```go
var a := 1
var b := [2, 3, 4]
var c := [5, 6, 7]
```

想要通过 `sum` 函数计算 `1 + (2 + 3 + 4)` 的结果。
可以写成

```go
var result := sum(a, b...)
```

此时，`b`中所有的元素，会展开到参数列表中。