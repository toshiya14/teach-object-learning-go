# 变量和常量

- 变量 - 指在程序运行过程中，可以被重复赋值的可以变更的代数符号，用`var`来标注。
- 常量 - 指被赋值过一次之后，就不可变更的代数符号，用`const`来标注。

```go
const PI = 3.1415
var r = 5

// 也可以用括号统一声明多个变量
var (
    a = 1
    b = 2
)
```

## 变量赋值

变量的值随时可以通过`变量名 = 新值`进行重新赋值，而且声明变量的时候，可以不带初始值，但是这种情况必须带有变量的类型

```go
var d int
var (
    e, f int
)

// 定义后再初始化
d = 1
e = 2
f = d + e

// 重新赋值
e = 5
d = e + f
```

也可以使用短声明：

```go
var a = 1
a := 1
```

上面两行等效，短声明在不能使用`var`关键字的地方使用。

## 基本类型

### 浮点数

```go
pi = 3.1415927
var pi = 3.1415927
var pi float64 = 3.1415927
```

上面的三种声明都是等效的。
如果希望给 `pi` 赋值一个整数，而不包含小数部分，但是又希望 `pi` 是个实数，就必须写明类型：

```go
var pi float64 = 3
```

go 语言里面会优先使用双精度类型。

精度：

- 单精度 (`float32`)
  - 32 位，对应占用内存 4 字节。
- 双精度 (`float64`)
  - 64 位，对应占用内存 8 字节。
  - 比单精度的有效小数精度更高。
  - 相当于和其他语言的 `double`。

浮点数的默认值是 `0.0`。

### 整型

整型分为有符号和无符号整型两种。无符号整型只能表示正整数和`0`。

|  类型  |    范围    |   占用内存   |
| :----: | :--------: | :----------: |
| `int8` | -128 ~ 127 | 8 位，1 字节 |
| `uint8` | 0 ~ 255 | 8 位，1 字节 |
| `int16` | -32768 ~ 32767 | 16 位，2 字节 |
| `uint16` | 0 ~ 65535 | 16 位，2 字节 |
| `int32` | - (2 的 31 次方) ~ (2 的 31 次方) - 1 | 32 位，4 字节 |
| `uint32` | 0 ~ (2 的 32 次方) | 32 位，4 字节 |
| `int64` | - (2 的 63 次方) ~ (2 的 63 次方) - 1 | 64 位，8 字节 |
| `uint64` | 0 ~ (2 的 64 次方) | 64 位，8 字节 |

`int` 和 `uint` 在较老的设备或者性能较低的设备上默认是 32 位，其他情况则是 64 位的。

### 十六进制

```go
var a = 0xff
```

加上前导 `0x` 表示一个十六进制数字。

### 内存溢出

当数值超过范围，再进行运算时，会发生溢出。
（扩展阅读：内存溢出的原理）

```go
var a = 127
a += 1
fmt.Println(a)
```
输出为 `-128`。

### 最大整数以及最小整数

`math`包中可以获取到各个类型的整数最大最小值。

```go
fmt.Println(math.MaxInt16)
fmt.Println(math.MinInt32)
```

### 扩展阅读：特别大的数字
一般，如果 `int64` 能够表示的数字，用 `int64` 就可以了。如果比 `int64` 还大，而且不需要负数区间，也可以用 `uint64`。
再大的话，虽然可以考虑用 `float64` 来表示，但是需要注意 `float64` 的精度问题，有的时候不能特别精确地表示一个数字。

`math/big` 这个包就可以解决这个问题。

#### 初始化 big Int

```go
a := big.NewInt(123)

b := new(big.Int)
b.SetString("123", 10)
```

以上两种形式都可以，但是如果使用第一种情况，传入的不是123，而是一个特别大的数字，超过了 go 语言可以处理的数字范围，就会报错。所以可以使用第二种方法，传入一个字符串，并且指定为 `10` 进制。他就会解析字符串，并且把这个数值处理后返回给 `b`。

`big.Int` 不能直接用运算符进行运算。
比如，`c := a / b` 需要写成 `c.Div(a, b)`。