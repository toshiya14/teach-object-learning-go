# 映射/字典 Map

由若干个 `key` 组成的集合，每个 `key` 都是唯一的值，而且映射为一个 `value`。而 `value` 不需要是唯一的。

例如，学号-姓名，可以算是一种映射关系，因为每个人的学号是唯一的，而且每个学号都映射一个姓名。学号不会重复，但是姓名有可能会有撞名的可能性。

* 通过 `key` 来寻找 `value` 所消耗的时间是常数时间，`O(1)`。
* 在 Go 语言中， `key` 的类型没有限制。

## 声明

```go
xuehao := map[string]string {
    "1001": "张三"
    "1002": "李四"
}
```

上面的表达式中，定义了一个`string`为`key`的类型，`string`为`value`的类型的映射。

## 取值

```go
value := xuehao["1001"]
```

如果取值时，指定的 `key` 不存在的话，就会返回 `value` 类型的零值。
比如 `string` 的零值是 空字符串 `""`，所以如果取 `xuehao["1099"]` 就会得到 `""`。

```go
value, ok := xuehao["1099"]
```

如上述，最后 `value` 的值是空字符串，如果我们后面还使用了第二个变量来接收取值的返回结果，就会得到取值是否成功的一个布尔类型的返回值。
在上面的例子中，如果取值成功就会使 `ok` 为 `true`，否则就是 `false`。
其实第一种写法，就是省略了第二个接收变量的写法。
取值或者函数执行的时候，如果有多个返回值，会依次返回到赋值前面的变量列表中，如果接收变量的数量不够的话，后面的返回结果会被抛弃。

## 修改/添加映射

```go
xuehao["1003"] = "王五"
```

如果 `"1003"` 这个 `key` 不存在的话，会自动新的，否则就会覆盖以前的。

## 传值

传递参数或者是赋值给新变量时，使用**引用传递**，不会复制新的数据副本。

## 删除元素

```go
delete(map变量名, key值)
```

## make 预分配

一般用于减少扩容次数，以及不需要数据的初始化。

```go
xuehao := make(map[string]string, 8)
```

上面就新建了一个容量为 `8` 的映射。

## 遍历

```go
for key, value := range xuehao {
    ...
}
```
遍历时不保证顺序，和添加时一致。

> 对切片、映射进行遍历时，如果切片和映射没有被初始化，此时，值为 `nil`(空)。range会自动跳过，而不会报错。
