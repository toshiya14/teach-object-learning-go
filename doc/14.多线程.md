# 多线程

在 Go 语言中，使用 `goroutine` 来替代其他语言中的线程的概念，但是其实也是大同小异，你可以把它当作是个线程来理解。

我们一般写的代码，如 `main` 函数，相当于主线程，主线程还可以创建很多分支线程，使用这种方式的优点：
1. 可以同时进行多项任务。
2. 多项任务之间互不影响。
3. 分支线程执行的时候，不会阻碍主线程的继续运行。
4. 主线程可以等待分支线程完成并获取结果。

需要注意的是，主线程退出时，所有的分支线程也会被清理掉，所以在主线程退出之前，需要对分支线程进行等待等操作。

## 同步和异步的概念

```go
a := dosth1()
b := dosth2()
```

假设上面的两个函数是同步的，代码执行到 `dosth1` 之后，会先执行 `dosth1` 里面的内容，然后返回给 `a`，之后，再去执行 `dosth2` 里面的内容，然后返回给 `b`。

所以，同步的结果，就是**按顺序执行**。同时可以保证 `dosth1` 会比 `dosth2` 更早地结束运行。

```go
a := go dosth1()
b := go dosth2()
```

假设上面两个函数是异步的，那么代码执行到 `dosth1` 之后，会创建一个线程给 `dosth1` 去执行里面的内容，而主线程不会等待，而是继续往下，就会再创建 `dosth2` 的线程。

所以，异步的结果，就是**同时执行**。不可保证两个函数谁先结束运行。

## goroutine

任何同步函数调用时，前面加上一个 `go` 关键字，就会启动新的 `goroutine` 来调用这个函数。

`goroutine` 不是真正的线程，会通过分时技术，在不同时间去调度执行不同 `goroutine` 的内容。

## channel

Go 语言中，使用 `channel` 在不同的 `goroutine` 之间传递数据。

### 创建

```go
c := make(chan int)
```

上面的例子就是创建了一个可以传递 `int` 数据的通道。

### 数据传递

```go
c <- 99
```

向通道 `c` 发送 `99`。

```go
a := <- c
```

从通道 `c` 中获取数据，并放在 `a` 变量中。

通道的零值是 `nil`。

